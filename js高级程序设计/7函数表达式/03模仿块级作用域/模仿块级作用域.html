<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>模仿块级作用域</title>
</head>

<body>
    <script>
    /**
     * js没有块级作用域
     * 可以模仿创造一个
     */

    function outputNumbers(count) {
        for (var i = 0; i < count; i++) {
            console.log(i);
        }
        console.log(i); //计数
    }
    outputNumbers();

    /**
     * 这个函数中定义了一个 for 循环，而变量 i 的初始值被设置为 0。在 Java、C++等语言中，变量 i 只会在 for 循环的语句块中有定义，循环一旦结束，变量 i 就会被销毁。可是在 JavaScrip 中，变量 i 是定义在 ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即 使像下面这样错误地重新声明同一个变量，也不会改变它的值。
     */

    /**
     * 意思是说能访问到循环里
     */

    function outputNumbers(count) {
        for (var i = 0; i < count; i++) {
            alert(i);
        }

        var i; //重新声明变量
        alert(i); //计数
    }

    /**
     *  (块级)私有作用域的匿名函数的语法如下
     */
    (function() {
        //块级作用域
    })();
    /**
     * 以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个 函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。
     */

    var count = 5;
    outputNumbers(count);

    /**
     * 这里初始化了变量 count，将其值设置为 5。当然，这里的变量是没有必要的，因为可以把值直接 传给函数。为了让代码更简洁，我们在调用函数时用 5 来代替变量 count，如下所示。
     */

    outputNumbers(5);

    /**
     * 这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。
     */

    var someFunction = function() {
        //块级作用域
    };
    someFunction();

    /**
     * 这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名 函数赋值给变量 someFunction 。 而调用函数的方式是在函数名称后面添加一对圆括号， 即 someFunction()。通过前面的例子我们知道，可以使用实际的值来取代变量 count，那在这里是不是 也可以用函数的值直接取代函数名呢？ 然而，下面的代码却会导致错误。
     */

    function() {
        //块级作用域
    }(); //出错

    /**
     * 这段代码会导致语法错误，是因为 JavaScript 将 function 关键字当作一个函数声明的开始，而函 数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式， 只要像下面这样给它加上一对圆括号即可。
     */

    (funciton() {
        //块级作用域
    })();

    /**
     * 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域
     */

    function outputNamber(count) {
        (function() {
            for (var i = 0; i < count; i++) { //能访问是因为这是一个闭包,能访问所有变量
                console.log(i);
            }
        })();
        console.log(i); //错误
    }

    /**
     * 在这个重写后的 outputNumbers()函数中，我们在 for 循环外部插入了一个私有作用域。在匿名 函数中定义的任何变量，都会在执行结束时被销毁。因此，变量 i 只能在循环中使用，使用后即被销毁。 而在私有作用域中能够访问变量 count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的 所有变量。
     */

    /**
     * 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型 应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可 以使用自己的变量，又不必担心搞乱全局作用域。
     */

    (function() {
        var now = new Date();
        if (now.getMonth() == 0 && now.getDate() == 1) {
            console.log('Happy new year!');
        }
    })();

    /**
     * 把上面这段代码放在全局作用域中，可以用来确定哪一天是 1 月 1 日；如果到了这一天，就会向用 户显示一条祝贺新年的消息。其中的变量 now 现在是匿名函数中的局部变量，而我们不必在全局作用域 中创建它。
     */
    /**
     * 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函 数执行完毕，就可以立即销毁其作用域链了。
     */
    </script>
</body>

</html>
