<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>模块</title>
</head>

<body>
    <script>
    /**
     * 前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。 按照惯例，JavaScript 是以对象字面量的方式来创建单例对象的。
     */

    /**
     * 对象字面量?
     */

    var dandu = {
        name: value,
        mothod: function() {
            //这里是方法代码
        }
    };

    /**
     * 通过模块为单例添加私有变量和特权方法
     */

    var danli = function() {
        var pv = 10;

        function pf() {
            return false;
        }
        //上面私有方法变量

        //由上面变为特权方法,暴露出去,是一个公共接口
        return{
        	pp:true,
        	pm:function(){
        		pv++;
        		return pf();
        	}
        };
    }();

    /**
     * 这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。 然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于 这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个 对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有 变量时是非常有用的，
     */

    var app = function(){
    	//组成私有变量和函数
    	var com = new Array();

    	//初始化
    	com.push(new BaseCom());

    	//公共
    	return {
    		getCom:function(){
    			return com.length;
    		},
    		regCom:function(){
    			if(typeof com == "object"){
    				com.push(com);
    			}
    		}
    	};
    }();
    /**
     * 在 Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一 个用于管理组件的 application 对象。在创建这个对象的过程中，首先声明了一个私有的 components 数组，并向数组中添加了一个 BaseComponent 的新实例（在这里不需要关心 BaseComponent 的代码，我 们只是用它来展示初始化操作）。而返回对象的 getComponentCount()和 registerComponent()方法，都 是有权访问数组 components 的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。
     */

    /**
     * 简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有 数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 Object 的实例，因为最终要通 过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不 会将它传递给一个函数。因此，也就没有什么必要使用 instanceof 操作符来检查其对象类型了。
     */
    </script>
</body>

</html>
